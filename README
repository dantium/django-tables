django-tables
=============

A Django QuerySet renderer.

Installation
------------

Adding django-tables to your INSTALLED_APPS settings is optional, it'll get
you the ability to load some template utilities via {% load tables %}, but
apart from that, ``import django_tables as tables`` should get you going.

Running the test suite
----------------------

The test suite uses py.test (from http://codespeak.net/py/dist/test.html).

Working with Tables
-------------------

A table class looks very much like a form:

    import django_tables as tables
    class CountryTable(tables.Table):
        name = tables.Column(verbose_name="Country Name")
        population = tables.Column(sortable=False, visible=False)
        time_zone = tables.Column(name="tz", default="UTC+1")

Instead of fields, you declare a column for every piece of data you want to
expose to the user.

To use the table, create an instance:

    countries = CountryTable([{'name': 'Germany', population: 80},
                              {'name': 'France', population: 64}])

Decide how the table should be sorted:

    countries.order_by = ('name',)
    assert [row.name for row in countries.row] == ['France', 'Germany']

    countries.order_by = ('-population',)
    assert [row.name for row in countries.row] == ['Germany', 'France']

If you pass the table object along into a template, you can do:

    {% for column in countries.columns %}
        {{column}}
    {% endfor %}

Which will give you:

    Country Name
    Timezone

Note that ``population`` is skipped (as it has ``visible=False``), that the
declared verbose name for the ``name`` column is used, and that ``time_zone``
is converted into a more beautiful string for output automatically.

There are few requirements for the source data of a table. It should be an
iterable with dict-like objects. Values found in the source data that are
not associated with a column are ignored, missing values are replaced by
the column default or None.

Common Workflow
~~~~~~~~~~~~~~~

Usually, you are going to use a table like this. Assuming ``CountryTable``
is defined as above, your view will create an instance and pass it to the
template:

    def list_countries(request):
        data = ...
        countries = CountryTable(data, order_by=request.GET.get('sort'))
        return render_to_response('list.html', {'table': countries})

Note that we are giving the incoming "sort" query string value directly to
the table, asking for a sort. All invalid column names will (by default) be
ignored. In this example, only "name" and "tz" are allowed, since:

    * "population" has sortable=False
    * "time_zone" has it's name overwritten with "tz".

Then, in the "list.html" template, write:

    <table>
    <tr>
        {% for column in table.columns %}
        <th><a href="?sort={{ column.name }}">{{ column }}</a></th>
        {% endfor %}
    </tr>
    {% for row in table.rows %}
        {% for value in row %}
            <td>{{ value }}<td>
        {% endfor %}
    {% endfor %}
    </table>

This will output the data as an HTML table. Note how the table is now fully
sortable, since our link passes along the column name via the querystring,
which in turn will be used by the server for ordering. ``order_by`` accepts
comma-separated strings as input, and "{{ table.order_by }}" will be rendered
as a such a string.

Instead of the iterator, you can use your knowledge of the table structure to
access columns directly:

        {% if table.columns.tz.visible %}
            {{ table.columns.tz }}
        {% endfor %}


Dynamic Data
~~~~~~~~~~~~

If any value in the source data is a callable, it will be passed it's own
row instance and is expected to return the actual value for this particular
table cell.

Similarily, the colunn default value may also be callable that will takes
the row instance as an argument (representing the row that the default is
needed for).


ModelTables
-----------

Like forms, tables can also be used with models:

    class CountryTable(tables.ModelTable):
        id = tables.Column(sortable=False, visible=False)
        class Meta:
            model = Country
            exclude = ['clicks']

The resulting table will have one column for each model field, with the
exception of "clicks", which is excluded. The column for "id" is overwritten
to both hide it and deny it sort capability.

When instantiating a ModelTable, you usually pass it a queryset to provide
the table data:

    qs = Country.objects.filter(continent="europe")
    countries = CountryTable(qs)

However, you can also just do:

    countries = CountryTable()

and all rows exposed by the default manager of the model the table is based
on will be used.

If you are using model inheritance, then the following also works:

    countries = CountryTable(CountrySubclass)

Note that while you can pass any model, it really only makes sense if the
model also provides fields for the columns you have defined.

If you just want to use ModelTables, but without auto-generated columns,
you do not have to list all model fields in the ``exclude`` Meta option.
Instead, simply don't specify a model.


Custom Columns
~~~~~~~~~~~~~~

You an add custom columns to your ModelTable that are not based on actual
model fields:

    class CountryTable(tables.ModelTable):
        custom = tables.Column(default="foo")
        class Meta:
            model = Country

Just make sure your model objects do provide an attribute with that name.
Functions are also supported, so ``Country.custom`` could be a callable.


Spanning relationships
~~~~~~~~~~~~~~~~~~~~~~

Let's assume you have a ``Country`` model, with a foreignkey ``capital``
pointing to the ``City`` model. While displaying a list of countries,
you might want want to link to the capital's geographic location, which is
stored in ``City.geo`` as a ``(lat, long)`` tuple, on Google Maps.

ModelTables support relationship spanning syntax of Django's database api:

    class CountryTable(tables.ModelTable):
        city__geo = tables.Column(name="geo")

This will add a column named "geo", based on the field by the same name
from the "city" relationship. Note that the name used to define the column
is what will be used to access the data, while the name-overwrite passed to
the column constructor just defines a prettier name for us to work with.
This is to be consistent with auto-generated columns based on model fields,
where the field/column name naturally equals the source name.

However, to make table defintions more visually appealing and easier to
read, an alternative syntax is supported: setting the column ``data``
property to the appropriate string.

    class CountryTable(tables.ModelTable):
        geo = tables.Column(data='city__geo')

Note that you don't need to define a relationship's fields as columns
simple to access them:

    for country in countries.rows:
        print country.city.id
        print country.city.geo
        print country.city.founder.name


ModelTable Specialities
~~~~~~~~~~~~~~~~~~~~~~~

ModelTables currently have some restrictions with respect to ordering:

    * Custom columns not based on a model field do not support ordering,
      regardless of the ``sortable`` property (it is ignored).

    * A ModelTable column's ``default`` or ``data`` value does not affect
      ordering. This differs from the non-model table behaviour.

If a column is mapped to a method on the model, that method will be called
without arguments. This behavior differs from non-model tables, where a
row object will be passed.

If you are using callables (e.g. for the ``default`` or ``data`` column
options), they will generally be run when a row is accessed, and
possible repeatetly when accessed more than once. This behavior differs from
non-model tables, where they would be called once, when the table is
generated.

Columns
-------

Columns are what defines a table. Therefore, the way you configure your
columns determines to a large extend how your table operates.

``django_tables.columns`` currently defines three classes, ``Column``,
``TextColumn`` and ``NumberColumn``. However, the two subclasses currently
don't do anything special at all, so you can simply use the base class.
While this will likely change in the future (e.g. when grouping is added),
the base column class will continue to work by itself.

There are no required arguments. The following is fine:

    class MyTable(tables.Table):
        c = tables.Column()

It will result in a column named "c" in the table. You can specify the
``name`` to override this:

    c = tables.Column(name="count")

The column is now called and accessed via "count", although the table will
still use "c" to read it's values from the source. You can however modify
that as well, by specifying ``data``:

    c = tables.Column(name="count", data="count")

For most practicual purposes, "c" is now meaningless. While in most cases
you will just define your column using the name you want it to have, the
above is useful when working with columns automatically generated from
models:

    class BookTable(tables.ModelTable):
        book_name = tables.Column(name="name")
        author = tables.Column(data="info__author__name")
        class Meta:
            model = Book

The overwritten ``book_name`` field/column will now be exposed as the
cleaner "name", and the new "author" column retrieves it's values from
``Book.info.author.name``.

Note: ``data`` may also be a callable which will be passed a row object.

Apart from their internal name, you can define a string that will be used
when for display via ``verbose_name``:

    pubdate = tables.Column(verbose_name="Published")

The verbose name will be used, for example, if you put in a template:

    {{ column }}

If you don't want a column to be sortable by the user:

    pubdate = tables.Column(sortable=False)

If you don't want to expose a column (but still require it to exist, for
example because it should be sortable nonetheless):

    pubdate = tables.Column(visible=False)

The column and it's values will now be skipped when iterating through the
table, although it can still be accessed manually.

Finally, you can specify default values for your columns:

    health_points = tables.Column(default=100)

Note that how the default is used and when it is applied differs between
static and ModelTables.


Tables and Pagination
---------------------

    table = MyTable(queryset)
    p = Paginator(table.rows, 10)  # paginator will need to be able to handle our modelproxy

    or

    table = MyTable(queryset)
    table.pagination = Paginator(10, padding=2)

    or

    table.paginate(DiggPaginator, 10, padding=2)


Ordering Syntax
---------------

Works exactly like in the Django database API. Order may be specified as
a list (or tuple) of column names. If prefixed with a hypen, the ordering
for that particular field will be in reverse order.

Random ordering is currently not supported.


Error handling
--------------

Passing incoming query string values from the request directly to the
table constructor is a common thing to do. However, such data can easily
be invalid, be it that a user manually modified it, or someone put up a
broken link. In those cases, you usually would not want to raise an
exception (nor be notified by Django's error notification mechanism) -
there is nothing you could do anyway.

Because of this, such errors will by default be silently ignored. For
example, if one out of three columns in an "order_by" is invalid, the other
two will still be applied:

    table.order_by = ('name', 'totallynotacolumn', '-date)
    assert table.order_by = ('name', '-date)

This ensures that the following table will be created regardless of the
string in "sort.

    table = MyTable(data, order_by=request.GET.get('sort'))

However, if you want, you can disable this behaviour and have an exception
raised instead, using:

    import django_tables
    django_tables.options.IGNORE_INVALID_OPTIONS = False


Template Utilities
------------------

If you want the give your users the ability to interact with your table (e.g.
change the ordering), you will need to create urls with the appropriate
queries. To simplify that process, django-tables comes with helpful
templatetag:

    {% set_url_param "sort" "name" %}       # ?sort=name
    {% set_url_param "sort" %}              # delete "sort" param

The template library can be found in 'django_modules.app.templates.tables'.
If you add ''django_modules.app' to your INSTALLED_APPS setting, you will
be able to do:

    {% load tables %}


TODO
----
    - as_html methods are all empty right now
    - table.column[].values is a stub
    - let columns change their default ordering (ascending/descending)
    - filters
    - grouping
    - choices support for columns (internal column value will be looked up
      for output)
    - for columns that span model relationships, automatically generate
      select_related(); this is important, since right now such an e.g.
      order_by would cause rows to be dropped (inner join).
    - initialize auto-generated columns with the relevant properties of the
      model fields (verbose_name, editable=visible?, ...)
    - remove support for callable fields? this has become obsolete since we
      Column.data property; also, it's easy to make the call manually, or let
      the template engine handle it
    - tests could use some refactoring, they are currently all over the place
    - what happens if duplicate column names are used? we currently don't
      check for that at all.